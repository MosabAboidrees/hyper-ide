
/*
 * Sanity checking arguments.
 */
micro.lambda.contract.optional:x:/..
  exact:bool
  filter:string





/*
 * Defaults.
 */
.defaults
  filter:/





/*
 * Retrieving all open editors, and checking that there actually are any
 * open editors, and if not, returning early.
 */
hyper-ide.editors.get-open-editors
if:x:/@hyper-ide.editors.get-open-editors/*?count
  =:int:0

  /*
   * No open editors, returning early to avoid evaluating the rest of our lambda.
   */
  return





/*
 * Retrieving active editor, since we'll need to track if it was closed or
 * not during lambda.
 */
hyper-ide.folder-explorer.get-active-item





/*
 * Iterating through all open editors.
 */
for-each:x:/@hyper-ide.editors.get-open-editors/*

  /*
   * Checking if currently iterated editor is a match for our [filter] condition.
   */
  if
    starts-with:x:/@_dp/#?name
      src:x:(/../*/filter|/@.defaults/*/filter)/$?value

    /*
     * Checking if we need an exact match.
     */
    if:x:/../*/exact?value
      =:bool:true
      and:x:/@_dp/#?name
        !=:x:(/../*/filter|/@.defaults/*/filter)/$?value

      /*
       * Caller wanted an exact match, and this was not an exact match.
       */
      continue

    /*
     * Deleting actual editor.
     */
    p5.web.widgets.find-first:hyper-ide-editor-tab-editors
      .editor:x:/@_dp/#?name
    delete-widget:x:/@p5.web.widgets.find-first/*/*?value

    /*
     * Then its activate button.
     */
    p5.web.widgets.find-first:hyper-ide-editor-tab-buttons
      .activate:x:/@_dp/#?name
    delete-widget:x:/@p5.web.widgets.find-first/*/*?value

    /*
     * Then its toolbar.
     */
    p5.web.widgets.find-first
      .toolbar:x:/@_dp/#?name
    delete-widget:x:/@p5.web.widgets.find-first/*/*?value

    /*
     * Removing currently iterated editor from our list of editors.
     *
     * This is done such that we end up with a list of available editors,
     * after we have closed all editors caller wants to close.
     */
    set:x:/@_dp/#





/*
 * Checking if active editor was deleted, and if it was, we'll need to
 * either load up another editor, or load our splash screen, depending 
 * upon whether or not there are anymore editors left in our collection.
 */
if:x:/@hyper-ide.folder-explorer.get-active-item?value
  =:x:(/../*/filter|/@.defaults/*/filter)/$?value
  or
    starts-with:x:/@hyper-ide.folder-explorer.get-active-item?value
      src:x:(/../*/filter|/@.defaults/*/filter)/$?value
    and:x:/../*/exact?value.bool
      !=:bool:true

  /*
   * Checking if there are anymore editors left.
   */
  if:x:/@hyper-ide.editors.get-open-editors/*?count
    >:int:0

    /*
     * Setting the first available editor as our active editor.
     */
    hyper-ide.editors.set-active-editor:x:/@hyper-ide.editors.get-open-editors/0?name

  else

    /*
     * No more editors, deleting editor wrapper, and loading our 
     * splash screen, making sure we also de-select any selected tree 
     * view items.
     */
    delete-widget:hyper-ide-editor-tab
    hyper-ide.load-splash
    micro.widgets.tree.select-items:hyper-ide-folder-tree-browser
      items

    /*
     * Making sure we show our solution explorer, if it is hidden.
     */
    micro.css.delete:hyper-ide-file-browser-wrapper
      class:hide
    micro.css.delete:hyper-ide-file-editor
      class:col
    micro.css.add:hyper-ide-file-editor
      class:col-70

else-if:x:/@hyper-ide.editors.get-open-editors/*?count
  >:int:0

  /*
   * Regardless of whether or not the active editor was deleted, we might 
   * need to make sure our active editor becomes selected in our tree, due
   * to what occurs when deletion of a folder occurs, etc.
   */
  hyper-ide.editors.set-active-editor:x:/@hyper-ide.editors.get-open-editors/0?name





/*
 * Checking if we have unsaved changes, and if so, returning false, otherwise
 * returning true.
 */
if
  fetch:x:/0/0?value
    widget-exists:hyper-ide-unsaved-changes-modal
  return:bool:false





/*
 * Evaluating any optional [.onclose] lambda callbacks.
 */
eval:x:/../*/.onclosed
return:bool:true
