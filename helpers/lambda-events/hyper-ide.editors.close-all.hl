
/*
 * Sanity checking arguments.
 */
micro.lambda.contract.min:x:/..
  filter:string
micro.lambda.contract.optional:x:/..
  exact:bool





/*
 * Retrieving all open editors, and checking that there actually are any
 * open editors, and if not, returning early since there's nothing to do.
 */
hyper-ide.editors.get-open-editors
if:x:/@hyper-ide.editors.get-open-editors/*?count
  =:int:0

  /*
   * No open editors, returning early to avoid evaluating the rest of our lambda.
   */
  eval:x:/../*/.onclosed
  return





/*
 * Retrieving active editor, since we'll need to track if it was closed or
 * not during lambda.
 */
.active-deleted:bool:false
hyper-ide.editors.get-active-editor-filepath





/*
 * Iterating through all open editors.
 */
for-each:x:/@hyper-ide.editors.get-open-editors/*

  /*
   * Checking if currently iterated editor is a match for our [filter] condition.
   */
  if
    starts-with:x:/@_dp/#?name
      src:x:/../*/filter?value

    /*
     * Checking if we need an exact match.
     */
    if:x:/../*/exact?value
      =:bool:true
      and:x:/@_dp/#?name
        !=:x:/../*/filter?value

      /*
       * Caller wanted an exact match, and this was not an exact match.
       */
      continue

    /*
     * Current editor is a match, making sure we delete it.
     * Checking if currently iterated editor is dirty.
     */
    if
      hyper-ide.editors.get-editor-is-dirty:x:/@_dp/#?name

      /*
       * Editor is dirty, and [force] was not set to true, hence asking user to
       * confirm that he wants to actually close the editor, giving him the
       * option of saving its content first.
       *
       * Making sure we only show one dialog though.
       */
      if
        fetch:x:/0/0?value
          widget-exists:hyper-ide-unsaved-changes-modal
        not

        /*
         * Asking user to confirm that he wants to have editor closed.
         */
        hyper-ide.editors.set-active-editor:x:/@_dp/#?name
        add:x:/+2/**/.onclosed
          src:x:/../*/.onclosed/*
        eval-x:x:/+/*/*/*/p/*/innerValue|/+/**(/.filter|/.file)
        create-widgets
          micro.widgets.modal:hyper-ide-unsaved-changes-modal
            widgets
              h3
                innerValue:Unsaved content
              p
                innerValue:<code>{0}</code> contains unsaved data. Do you wish to save it before closing your editor?
                  :x:/@_dp/#?name
              div
                class:right
                widgets
                  div
                    class:strip
                    widgets
                      button
                        innerValue:Yes
                        oninit

                          /*
                           * Making sure our "Yes" button gets initial focus.
                           */
                          micro.page.set-focus:x:/../*/_event?value

                        onclick

                          /*
                           * Forward evaluated above.
                           * Saves given editor, and reinvokes self.
                           */
                          .file:x:/@_dp/#?name
                          .filter:x:/../*/filter?value
                          .onclosed
                          hyper-ide.editors.save-active-editor:x:/@.file?value

                          /*
                           * Deleting modal widget, and giving user some feedback,
                           * before we invoke "self".
                           */
                          delete-widget:hyper-ide-unsaved-changes-modal
                          micro.windows.info:File successfully saved
                            class:micro-windows-info success
                          add:x:/../*/hyper-ide.editors.close-all
                            src:x:/@.onclosed
                          eval-x:x:/+/*
                          hyper-ide.editors.close-all
                            filter:x:/@.filter?value

                      button
                        innerValue:No
                        onclick

                          /*
                           * Forward evaluated above.
                           * Reinvokes self after having set editor to "clean".
                           */
                          .file:x:/@_dp/#?name
                          .filter:x:/../*/filter?value
                          .onclosed
                          hyper-ide.editors.set-editor-clean-flag:x:/@.file?value

                          /*
                           * Deleting modal widget, before we invoke "self".
                           */
                          delete-widget:hyper-ide-unsaved-changes-modal
                          add:x:/../*/hyper-ide.editors.close-all
                            src:x:/@.onclosed
                          eval-x:x:/+/*
                          hyper-ide.editors.close-all
                            filter:x:/@.filter?value

    else

      /*
       * Editor is not dirty.
       * Deleting actual editor.
       */
      p5.web.widgets.find-first:hyper-ide-editor-tab-editors
        .editor:x:/@_dp/#?name
      delete-widget:x:/@p5.web.widgets.find-first/*/*?value

      /*
       * Then its activate button.
       */
      p5.web.widgets.find-first:hyper-ide-editor-tab-buttons
        .activate:x:/@_dp/#?name
      delete-widget:x:/@p5.web.widgets.find-first/*/*?value

      /*
       * Then its toolbar.
       */
      p5.web.widgets.find-first
        .toolbar:x:/@_dp/#?name
      delete-widget:x:/@p5.web.widgets.find-first/*/*?value

      /*
       * Checking if currently closed editor was the active editor.
       */
      if:x:/@_dp/#?name
        =:x:/@hyper-ide.editors.get-active-editor-filepath?value

        /*
         * Tracking the fact that our active editor was closed.
         */
        set:x:/@.active-deleted?value
          src:bool:true

        /*
         * Notice, when the active editor is deleted, we'll also need to check
         * if the file object toolbar was created for our active editor, and
         * if it was, we'll need to delete it too.
         */
        if
          fetch:x:/0/0?value
            widget-exists:hyper-ide-active-file-object-toolbar
          get-widget-property:hyper-ide-active-file-object-toolbar
            .file
          if:x:/@get-widget-property/*/*?value
            =:x:/@_dp/#?name

            /*
             * Current active file object toolbar was created for the active editor,
             * hence making sure we delete it.
             */
            delete-widget:hyper-ide-active-file-object-toolbar

      /*
       * Removing currently iterated editor from our list of editors.
       *
       * This is done such that we end up with a list of available editors,
       * after we have closed all editors caller wants to close.
       */
      set:x:/@_dp/#





/*
 * Checking if active editor was deleted, and if it was, we'll need to
 * either load up another editor, or load our splash screen, depending 
 * upon whether or not there are anymore editors left in our collection.
 */
if:x:/@.active-deleted?value
  =:bool:true

  /*
   * Checking if there are anymore editors left.
   */
  if:x:/@hyper-ide.editors.get-open-editors/*?count
    >:int:0

    /*
     * Setting the first available editor as our active editor.
     */
    hyper-ide.editors.set-active-editor:x:/@hyper-ide.editors.get-open-editors/0?name

  else

    /*
     * No more editors, deleting editor wrapper, and loading our 
     * splash screen, making sure we also un-select any selected tree 
     * view items.
     */
    delete-widget:hyper-ide-editor-tab
    hyper-ide.load-splash
    micro.widgets.tree.select-items:hyper-ide-folder-tree-browser
      items

    /*
     * Making sure we show our solution explorer, if it is hidden.
     */
    micro.css.delete:hyper-ide-file-browser-wrapper
      class:hide
    micro.css.delete:hyper-ide-file-editor
      class:col
    micro.css.add:hyper-ide-file-editor
      class:col-70

else-if:x:/@hyper-ide.editors.get-open-editors/*?count
  >:int:0

  /*
   * Regardless of whether or not the active editor was deleted, we might 
   * need to make sure our active editor becomes selected in our tree, due
   * to what occurs when deletion of a folder occurs, etc.
   */
  hyper-ide.editors.set-active-editor:@hyper-ide.editors.get-open-editors/0?name





/*
 * Checking if we have unsaved changes, and if so, returning false, otherwise
 * returning true.
 */
if
  fetch:x:/0/0?value
    widget-exists:hyper-ide-unsaved-changes-modal
  return:bool:false





/*
 * Evaluating any optional [.onclose] lambda callbacks.
 */
eval:x:/../*/.onclosed
return:bool:true
