# Introduction - The pan galactical gargle blaster

This chapter discuss some of the philosophical and psychological implications of learning Hyperlambda. The chapter is not necessary to read, if you only want to learn Hyperlambda and P5. However, I believe that the more broad your knowledge about anything becomes, the better suited you are to learn something very narrow. If you don't want to read about my philosophical reasons for designing Hyperlambda the way I did, feel free to skip to the [next chapter](chapter-9.md).

> Everything you know is wrong!

My *"theory of mind"* is based upon the assumption that the same way Newton's laws applies to physical things and energies, it also to some extent applies to cognitive energies. This implies that whenever you apply cognitive energies to creating software, the thing you are trying to create, applies the same amount of cognitive energy back unto your brain. If my theory is correct, this implies, that as you create software, the software you create, physically rewires your brain. This theory resonates with everything we see around us, and should be intuitively understood, by those with some basic scientific knowledge about our world.

Today, there are probably few objections to my assumption of that software developers are gravitating towards their left hemisphere in regards to all cognitive types of energies. This starves the right hemisphere, which is where our creativity is seated. If you don't believe me, then please *"go create an app"*. I will not tell you *which* app to create, just go and create *"an app"*. Or to put it another way, create a list of 5 apps you would want to create with Phosphorus Five. If you can do this in less than 5 minutes, you have a strong right hemisphere. If you cannot do this within 30 minutes, you're in trouble!

## To see the stuff that's not there

Phosphorus Five, forces you to visualize that which is not there. Meaning, the intangible stuff, that's inbetween your code. This forces you to use your right hemisphere, to a much larger extent, than traditional programming. The **[apply]** active event from our previous chapter, is one example of this.

This has the effect of balancing your brain, such that the art of programming, doesn't necessarily overfeed your left hemisphere, while starving your right - Instead, it nurtures *both* hemispheres equally much.

All other programming languages today, are extremely logical beasts. Hyperlambda is a much more smooth and soft programming language. Among other things, as we've clearly seen so far, it *"morphes"* in accordance to its environment, to a much larger extent, than what for instance a language such as C++ or C# does. To use an analogy, traditional programming languages are masculine in nature, while Hyperlambda is feminine in nature.

This trait of Hyperlambda, makes it a perfect orchestration programming language, allowing you to orchestrate your logical and masculine parts together, in a softer and more feminine environment. In such a way, it solves something that has arguably never been solved previously in regards to the art of programming. The thing it solves, also happens to be a very useful thing. If you believe in women having value, you must purely logically believe that P5 have value.

**Notice**, I am probably going to get in trouble with a huge group of liberals and neo feminists here for my choice of words. However, the truth is still the truth, and there are no chauvinistic reasoning behind my theory - I simply state the obvious, which is that there are differences between our sexes. This doesn't imply that one of our sexes are more important than the other. It simply states that there **are differences**. I happen to believe though, that what I refer to as general _"feminine traits"_, happens to add value to the art of programming. If that is a chauvinistic point of view, well, then I guess I am a chauvinist.

## Should you use Hyperlambda for everything?

Short answer; *NO* - There are things that C# or C++ does much better than Hyperlambda - And Hyperlambda, might never be able to solve all things, as nicely as other programming languages solves these concepts. However, Hyperlambda was built to be an orchestration programming language. This allows you to take all of your beautiful algorithms, classes, and pre-existing logical components, and melt them together, making them nicely collaborate with each other. However, for this particular task, Hyperlambda and P5 happens to be vastely superior.

The above explanation is the reason why I have waited with the introduction of this book, until chapter 8. Simply because this idea is difficult to believe in, before you've had some hands on experience with Hyperlambda.

### Sorry for not being sorry for messing with your brain

The above header, is not funny in fact, unless you've done quite a lot of Hyperlambda development. However, once you understand Hyperlambda's ins and outs, you will probably laugh of the above header.

The reason is that Hyperlambda allows you to create a meta-cognitive understanding of logic, being able to understand not only logic, from a logical point of view, but also in fact illogical things, from a logical point of view. It allows you to *"think in layers"*, applying meta cognitive understanding, to your own understanding - And more importantly, it allows your software to have these same traits.

Facts are, as you use Hyperlambda and Phosphorus Five, you will slowly understand what I mean, when I say the following; *"Hyperlambda understands Hyperlambda"*. However, this requires having balanced your hemispheres, and having practiced your visualisation skills, which again results in that you become a better developer, not only in *"dynamic languages"*, but also in static languages. It allows you to *"see that which is not there"*.

To illustrate that idea, with a substantial portion of self irony, I have chosen to create a chapter, which by itself is a bug! Keep on reading, and hopefully I'll make you laugh - Since this happens to be a pre-requisite for acquiring contact with your right hemisphere ...

[Chapter 9, The bug](chapter-9.md)
